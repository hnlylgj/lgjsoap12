/* soapStub.h
   Generated by gSOAP 2.8.34 for adas.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_NAMESPACE_OF_ns1	"http://www.vispect.com/"
#define SOAP_NAMESPACE_OF_ser	"http://schemas.microsoft.com/2003/10/Serialization/"
#define SOAP_NAMESPACE_OF_ns2	"http://www.vispect.com/SmartCarBaseLib/"
#define SOAP_NAMESPACE_OF_arr	"http://schemas.microsoft.com/2003/10/Serialization/Arrays"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20834
# error "GSOAP VERSION 20834 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* custom/duration.h:90 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (17)
typedef LONG64 xsd__duration;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__anyType;	/* adas.h:148 */
class xsd__base64Binary;	/* adas.h:151 */
class xsd__ID_;	/* adas.h:172 */
class xsd__IDREF_;	/* adas.h:182 */
class xsd__QName;	/* adas.h:189 */
class xsd__anyURI_;	/* adas.h:199 */
class xsd__base64Binary_;	/* adas.h:206 */
class xsd__boolean;	/* adas.h:213 */
class xsd__byte_;	/* adas.h:220 */
class xsd__dateTime;	/* adas.h:227 */
class xsd__decimal_;	/* adas.h:237 */
class xsd__double;	/* adas.h:244 */
class xsd__duration_;	/* adas.h:251 */
class xsd__float;	/* adas.h:258 */
class xsd__int;	/* adas.h:265 */
class xsd__long;	/* adas.h:272 */
class xsd__short;	/* adas.h:279 */
class xsd__string;	/* adas.h:286 */
class xsd__unsignedByte_;	/* adas.h:293 */
class xsd__unsignedInt;	/* adas.h:300 */
class xsd__unsignedLong;	/* adas.h:307 */
class xsd__unsignedShort;	/* adas.h:314 */
class _ns1__RegisterAccount;	/* adas.h:328 */
class _ns1__RegisterAccountResponse;	/* adas.h:331 */
class _ns1__UpdatePassWord;	/* adas.h:334 */
class _ns1__UpdatePassWordResponse;	/* adas.h:337 */
class _ns1__LoginCloud;	/* adas.h:340 */
class _ns1__LoginCloudResponse;	/* adas.h:343 */
class _ns1__GetAccount;	/* adas.h:346 */
class _ns1__GetAccountResponse;	/* adas.h:349 */
class _ns1__SelectAccount;	/* adas.h:352 */
class _ns1__SelectAccountResponse;	/* adas.h:355 */
class _ns1__SetAccount;	/* adas.h:358 */
class _ns1__SetAccountResponse;	/* adas.h:361 */
class _ns1__EditAccount;	/* adas.h:364 */
class _ns1__EditAccountResponse;	/* adas.h:367 */
class _ns1__CreateDevice;	/* adas.h:370 */
class _ns1__CreateDeviceResponse;	/* adas.h:373 */
class _ns1__MadeDevice;	/* adas.h:376 */
class _ns1__MadeDeviceResponse;	/* adas.h:379 */
class _ns1__SaleDevice;	/* adas.h:382 */
class _ns1__SaleDeviceResponse;	/* adas.h:385 */
class _ns1__BindingDevice;	/* adas.h:388 */
class _ns1__BindingDeviceResponse;	/* adas.h:391 */
class _ns1__GetDevice;	/* adas.h:394 */
class _ns1__GetDeviceResponse;	/* adas.h:397 */
class _ns1__SendSmartWarn;	/* adas.h:400 */
class _ns1__SendSmartWarnResponse;	/* adas.h:403 */
class _ns1__PostListSmartWarn;	/* adas.h:406 */
class _ns1__PostListSmartWarnResponse;	/* adas.h:409 */
class _ns1__GetSmartWarn;	/* adas.h:412 */
class _ns1__GetSmartWarnResponse;	/* adas.h:415 */
class _ns1__TotalSmartWarn;	/* adas.h:418 */
class _ns1__TotalSmartWarnResponse;	/* adas.h:421 */
class _ns1__SendCarRunState;	/* adas.h:424 */
class _ns1__SendCarRunStateResponse;	/* adas.h:427 */
class _ns1__PostListCarRunState;	/* adas.h:430 */
class _ns1__PostListCarRunStateResponse;	/* adas.h:433 */
class _ns1__GetCarRunState;	/* adas.h:436 */
class _ns1__GetCarRunStateResponse;	/* adas.h:439 */
class ns2__ArrayOfPrimeAccount;	/* adas.h:442 */
class ns2__PrimeAccount;	/* adas.h:445 */
class arr__ArrayOfstring;	/* adas.h:448 */
struct __ns1__RegisterAccount;	/* adas.h:1806 */
struct __ns1__UpdatePassWord;	/* adas.h:1879 */
struct __ns1__LoginCloud;	/* adas.h:1952 */
struct __ns1__GetAccount;	/* adas.h:2025 */
struct __ns1__SelectAccount;	/* adas.h:2098 */
struct __ns1__SetAccount;	/* adas.h:2171 */
struct __ns1__EditAccount;	/* adas.h:2244 */
struct __ns1__CreateDevice;	/* adas.h:2317 */
struct __ns1__MadeDevice;	/* adas.h:2390 */
struct __ns1__SaleDevice;	/* adas.h:2463 */
struct __ns1__BindingDevice;	/* adas.h:2536 */
struct __ns1__GetDevice;	/* adas.h:2609 */
struct __ns1__SendSmartWarn;	/* adas.h:2682 */
struct __ns1__PostListSmartWarn;	/* adas.h:2755 */
struct __ns1__GetSmartWarn;	/* adas.h:2828 */
struct __ns1__TotalSmartWarn;	/* adas.h:2901 */
struct __ns1__SendCarRunState;	/* adas.h:2974 */
struct __ns1__PostListCarRunState;	/* adas.h:3047 */
struct __ns1__GetCarRunState;	/* adas.h:3120 */

/* adas.h:148 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (7)
/* Type xsd__anyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW(xsd__anyType); }
      public:
        /// Constructor with initializations
        xsd__anyType()
        {
          __item = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:151 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (9)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XSD type 'xsd:string'
        char *id;
        /// Optional element 'type' of XSD type 'xsd:string'
        char *type;
        /// Optional element 'options' of XSD type 'xsd:string'
        char *options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
      public:
        /// Constructor with initializations
        xsd__base64Binary()
        {
          __ptr = (unsigned char *)0;
          __size = 0;
          id = NULL;
          type = (char *)0;
          options = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:172 */
#ifndef SOAP_TYPE_xsd__ID_
#define SOAP_TYPE_xsd__ID_ (21)
/* Type xsd__ID_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:ID': */
class SOAP_CMAC xsd__ID_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:ID' wrapped by this struct
        std::wstring __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__ID_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__ID_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__ID_, default initialized and not managed by a soap context
        virtual xsd__ID_ *soap_alloc(void) const { return SOAP_NEW(xsd__ID_); }
      public:
        /// Constructor with initializations
        xsd__ID_()
        {
        }
        virtual ~xsd__ID_() { }
        /// Friend allocator used by soap_new_xsd__ID_(struct soap*, int)
        friend SOAP_FMAC1 xsd__ID_ * SOAP_FMAC2 soap_instantiate_xsd__ID_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:182 */
#ifndef SOAP_TYPE_xsd__IDREF_
#define SOAP_TYPE_xsd__IDREF_ (23)
/* Type xsd__IDREF_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:IDREF': */
class SOAP_CMAC xsd__IDREF_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:IDREF' wrapped by this struct
        std::wstring __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__IDREF_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__IDREF_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__IDREF_, default initialized and not managed by a soap context
        virtual xsd__IDREF_ *soap_alloc(void) const { return SOAP_NEW(xsd__IDREF_); }
      public:
        /// Constructor with initializations
        xsd__IDREF_()
        {
        }
        virtual ~xsd__IDREF_() { }
        /// Friend allocator used by soap_new_xsd__IDREF_(struct soap*, int)
        friend SOAP_FMAC1 xsd__IDREF_ * SOAP_FMAC2 soap_instantiate_xsd__IDREF_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:189 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (24)
/* Type xsd__QName is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:QName': */
class SOAP_CMAC xsd__QName : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:QName' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__QName
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__QName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__QName, default initialized and not managed by a soap context
        virtual xsd__QName *soap_alloc(void) const { return SOAP_NEW(xsd__QName); }
      public:
        /// Constructor with initializations
        xsd__QName()
        {
          __item = (char *)0;
        }
        virtual ~xsd__QName() { }
        /// Friend allocator used by soap_new_xsd__QName(struct soap*, int)
        friend SOAP_FMAC1 xsd__QName * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:199 */
#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (26)
/* Type xsd__anyURI_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:anyURI': */
class SOAP_CMAC xsd__anyURI_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:anyURI' wrapped by this struct
        std::wstring __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyURI_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__anyURI_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyURI_, default initialized and not managed by a soap context
        virtual xsd__anyURI_ *soap_alloc(void) const { return SOAP_NEW(xsd__anyURI_); }
      public:
        /// Constructor with initializations
        xsd__anyURI_()
        {
        }
        virtual ~xsd__anyURI_() { }
        /// Friend allocator used by soap_new_xsd__anyURI_(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyURI_ * SOAP_FMAC2 soap_instantiate_xsd__anyURI_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:206 */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (27)
/* Type xsd__base64Binary_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:base64Binary': */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary_, default initialized and not managed by a soap context
        virtual xsd__base64Binary_ *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary_); }
      public:
        /// Constructor with initializations
        xsd__base64Binary_()
        {
        }
        virtual ~xsd__base64Binary_() { }
        /// Friend allocator used by soap_new_xsd__base64Binary_(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary_ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:213 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (28)
/* Type xsd__boolean is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:boolean': */
class SOAP_CMAC xsd__boolean : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__boolean
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__boolean; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean, default initialized and not managed by a soap context
        virtual xsd__boolean *soap_alloc(void) const { return SOAP_NEW(xsd__boolean); }
      public:
        /// Constructor with initializations
        xsd__boolean()
        {
          __item = (bool)0;
        }
        virtual ~xsd__boolean() { }
        /// Friend allocator used by soap_new_xsd__boolean(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:220 */
#ifndef SOAP_TYPE_xsd__byte_
#define SOAP_TYPE_xsd__byte_ (30)
/* Type xsd__byte_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:byte': */
class SOAP_CMAC xsd__byte_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:byte' wrapped by this struct
        char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__byte_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__byte_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__byte_, default initialized and not managed by a soap context
        virtual xsd__byte_ *soap_alloc(void) const { return SOAP_NEW(xsd__byte_); }
      public:
        /// Constructor with initializations
        xsd__byte_()
        {
          __item = (char)0;
        }
        virtual ~xsd__byte_() { }
        /// Friend allocator used by soap_new_xsd__byte_(struct soap*, int)
        friend SOAP_FMAC1 xsd__byte_ * SOAP_FMAC2 soap_instantiate_xsd__byte_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:227 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (31)
/* Type xsd__dateTime is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:dateTime': */
class SOAP_CMAC xsd__dateTime : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:dateTime' wrapped by this struct
        time_t __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__dateTime
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__dateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__dateTime, default initialized and not managed by a soap context
        virtual xsd__dateTime *soap_alloc(void) const { return SOAP_NEW(xsd__dateTime); }
      public:
        /// Constructor with initializations
        xsd__dateTime()
        {
          __item = (time_t)0;
        }
        virtual ~xsd__dateTime() { }
        /// Friend allocator used by soap_new_xsd__dateTime(struct soap*, int)
        friend SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:237 */
#ifndef SOAP_TYPE_xsd__decimal_
#define SOAP_TYPE_xsd__decimal_ (34)
/* Type xsd__decimal_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:decimal': */
class SOAP_CMAC xsd__decimal_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:decimal' wrapped by this struct
        std::wstring __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__decimal_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__decimal_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__decimal_, default initialized and not managed by a soap context
        virtual xsd__decimal_ *soap_alloc(void) const { return SOAP_NEW(xsd__decimal_); }
      public:
        /// Constructor with initializations
        xsd__decimal_()
        {
        }
        virtual ~xsd__decimal_() { }
        /// Friend allocator used by soap_new_xsd__decimal_(struct soap*, int)
        friend SOAP_FMAC1 xsd__decimal_ * SOAP_FMAC2 soap_instantiate_xsd__decimal_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:244 */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (35)
/* Type xsd__double is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:double': */
class SOAP_CMAC xsd__double : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:double' wrapped by this struct
        double __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__double
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__double; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__double, default initialized and not managed by a soap context
        virtual xsd__double *soap_alloc(void) const { return SOAP_NEW(xsd__double); }
      public:
        /// Constructor with initializations
        xsd__double()
        {
          __item = (double)0;
        }
        virtual ~xsd__double() { }
        /// Friend allocator used by soap_new_xsd__double(struct soap*, int)
        friend SOAP_FMAC1 xsd__double * SOAP_FMAC2 soap_instantiate_xsd__double(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:251 */
#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (37)
/* Type xsd__duration_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:duration': */
class SOAP_CMAC xsd__duration_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:duration' wrapped by this struct
        LONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__duration_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__duration_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__duration_, default initialized and not managed by a soap context
        virtual xsd__duration_ *soap_alloc(void) const { return SOAP_NEW(xsd__duration_); }
      public:
        /// Constructor with initializations
        xsd__duration_()
        {
          __item = (LONG64)0;
        }
        virtual ~xsd__duration_() { }
        /// Friend allocator used by soap_new_xsd__duration_(struct soap*, int)
        friend SOAP_FMAC1 xsd__duration_ * SOAP_FMAC2 soap_instantiate_xsd__duration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:258 */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (38)
/* Type xsd__float is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:float': */
class SOAP_CMAC xsd__float : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:float' wrapped by this struct
        float __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__float
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__float; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__float, default initialized and not managed by a soap context
        virtual xsd__float *soap_alloc(void) const { return SOAP_NEW(xsd__float); }
      public:
        /// Constructor with initializations
        xsd__float()
        {
          __item = (float)0;
        }
        virtual ~xsd__float() { }
        /// Friend allocator used by soap_new_xsd__float(struct soap*, int)
        friend SOAP_FMAC1 xsd__float * SOAP_FMAC2 soap_instantiate_xsd__float(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:265 */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (40)
/* Type xsd__int is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:int': */
class SOAP_CMAC xsd__int : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:int' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__int
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__int; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__int, default initialized and not managed by a soap context
        virtual xsd__int *soap_alloc(void) const { return SOAP_NEW(xsd__int); }
      public:
        /// Constructor with initializations
        xsd__int()
        {
          __item = (int)0;
        }
        virtual ~xsd__int() { }
        /// Friend allocator used by soap_new_xsd__int(struct soap*, int)
        friend SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:272 */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (41)
/* Type xsd__long is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:long': */
class SOAP_CMAC xsd__long : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:long' wrapped by this struct
        LONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__long
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__long; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__long, default initialized and not managed by a soap context
        virtual xsd__long *soap_alloc(void) const { return SOAP_NEW(xsd__long); }
      public:
        /// Constructor with initializations
        xsd__long()
        {
          __item = (LONG64)0;
        }
        virtual ~xsd__long() { }
        /// Friend allocator used by soap_new_xsd__long(struct soap*, int)
        friend SOAP_FMAC1 xsd__long * SOAP_FMAC2 soap_instantiate_xsd__long(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:279 */
#ifndef SOAP_TYPE_xsd__short
#define SOAP_TYPE_xsd__short (43)
/* Type xsd__short is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:short': */
class SOAP_CMAC xsd__short : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:short' wrapped by this struct
        short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__short
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__short; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__short, default initialized and not managed by a soap context
        virtual xsd__short *soap_alloc(void) const { return SOAP_NEW(xsd__short); }
      public:
        /// Constructor with initializations
        xsd__short()
        {
          __item = (short)0;
        }
        virtual ~xsd__short() { }
        /// Friend allocator used by soap_new_xsd__short(struct soap*, int)
        friend SOAP_FMAC1 xsd__short * SOAP_FMAC2 soap_instantiate_xsd__short(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:286 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (45)
/* Type xsd__string is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:string': */
class SOAP_CMAC xsd__string : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::wstring __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__string
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__string; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string, default initialized and not managed by a soap context
        virtual xsd__string *soap_alloc(void) const { return SOAP_NEW(xsd__string); }
      public:
        /// Constructor with initializations
        xsd__string()
        {
        }
        virtual ~xsd__string() { }
        /// Friend allocator used by soap_new_xsd__string(struct soap*, int)
        friend SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:293 */
#ifndef SOAP_TYPE_xsd__unsignedByte_
#define SOAP_TYPE_xsd__unsignedByte_ (46)
/* Type xsd__unsignedByte_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedByte': */
class SOAP_CMAC xsd__unsignedByte_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedByte' wrapped by this struct
        unsigned char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedByte_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedByte_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedByte_, default initialized and not managed by a soap context
        virtual xsd__unsignedByte_ *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedByte_); }
      public:
        /// Constructor with initializations
        xsd__unsignedByte_()
        {
          __item = (unsigned char)0;
        }
        virtual ~xsd__unsignedByte_() { }
        /// Friend allocator used by soap_new_xsd__unsignedByte_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedByte_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedByte_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:300 */
#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (47)
/* Type xsd__unsignedInt is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedInt': */
class SOAP_CMAC xsd__unsignedInt : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedInt' wrapped by this struct
        unsigned int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedInt
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedInt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedInt, default initialized and not managed by a soap context
        virtual xsd__unsignedInt *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedInt); }
      public:
        /// Constructor with initializations
        xsd__unsignedInt()
        {
          __item = (unsigned int)0;
        }
        virtual ~xsd__unsignedInt() { }
        /// Friend allocator used by soap_new_xsd__unsignedInt(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedInt * SOAP_FMAC2 soap_instantiate_xsd__unsignedInt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:307 */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (48)
/* Type xsd__unsignedLong is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedLong': */
class SOAP_CMAC xsd__unsignedLong : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedLong' wrapped by this struct
        ULONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedLong
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedLong; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedLong, default initialized and not managed by a soap context
        virtual xsd__unsignedLong *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedLong); }
      public:
        /// Constructor with initializations
        xsd__unsignedLong()
        {
          __item = (ULONG64)0;
        }
        virtual ~xsd__unsignedLong() { }
        /// Friend allocator used by soap_new_xsd__unsignedLong(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedLong * SOAP_FMAC2 soap_instantiate_xsd__unsignedLong(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:314 */
#ifndef SOAP_TYPE_xsd__unsignedShort
#define SOAP_TYPE_xsd__unsignedShort (50)
/* Type xsd__unsignedShort is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedShort': */
class SOAP_CMAC xsd__unsignedShort : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedShort' wrapped by this struct
        unsigned short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedShort
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedShort; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedShort, default initialized and not managed by a soap context
        virtual xsd__unsignedShort *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedShort); }
      public:
        /// Constructor with initializations
        xsd__unsignedShort()
        {
          __item = (unsigned short)0;
        }
        virtual ~xsd__unsignedShort() { }
        /// Friend allocator used by soap_new_xsd__unsignedShort(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedShort * SOAP_FMAC2 soap_instantiate_xsd__unsignedShort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:328 */
#ifndef SOAP_TYPE__ns1__RegisterAccount
#define SOAP_TYPE__ns1__RegisterAccount (52)
/* complex XSD type 'ns1:RegisterAccount': */
class SOAP_CMAC _ns1__RegisterAccount {
      public:
        /// Optional element 'ns1:LoginName' of XSD type 'xsd:string'
        wchar_t *LoginName;
        /// Optional element 'ns1:PassWord' of XSD type 'xsd:string'
        wchar_t *PassWord;
        /// Optional element 'ns1:AccountID' of XSD type 'xsd:string'
        wchar_t *AccountID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RegisterAccount
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RegisterAccount; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RegisterAccount, default initialized and not managed by a soap context
        virtual _ns1__RegisterAccount *soap_alloc(void) const { return SOAP_NEW(_ns1__RegisterAccount); }
      public:
        /// Constructor with initializations
        _ns1__RegisterAccount()
        {
          LoginName = (wchar_t *)0;
          PassWord = (wchar_t *)0;
          AccountID = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RegisterAccount() { }
        /// Friend allocator used by soap_new__ns1__RegisterAccount(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RegisterAccount * SOAP_FMAC2 soap_instantiate__ns1__RegisterAccount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:331 */
#ifndef SOAP_TYPE__ns1__RegisterAccountResponse
#define SOAP_TYPE__ns1__RegisterAccountResponse (53)
/* complex XSD type 'ns1:RegisterAccountResponse': */
class SOAP_CMAC _ns1__RegisterAccountResponse {
      public:
        /// Optional element 'ns1:RegisterAccountResult' of XSD type 'xsd:int'
        int *RegisterAccountResult;
        /// Optional element 'ns1:AccountID' of XSD type 'xsd:string'
        wchar_t *AccountID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RegisterAccountResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RegisterAccountResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RegisterAccountResponse, default initialized and not managed by a soap context
        virtual _ns1__RegisterAccountResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RegisterAccountResponse); }
      public:
        /// Constructor with initializations
        _ns1__RegisterAccountResponse()
        {
          RegisterAccountResult = (int *)0;
          AccountID = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RegisterAccountResponse() { }
        /// Friend allocator used by soap_new__ns1__RegisterAccountResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RegisterAccountResponse * SOAP_FMAC2 soap_instantiate__ns1__RegisterAccountResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:334 */
#ifndef SOAP_TYPE__ns1__UpdatePassWord
#define SOAP_TYPE__ns1__UpdatePassWord (54)
/* complex XSD type 'ns1:UpdatePassWord': */
class SOAP_CMAC _ns1__UpdatePassWord {
      public:
        /// Optional element 'ns1:LoginName' of XSD type 'xsd:string'
        wchar_t *LoginName;
        /// Optional element 'ns1:PassWord' of XSD type 'xsd:string'
        wchar_t *PassWord;
        /// Optional element 'ns1:AccountID' of XSD type 'xsd:string'
        wchar_t *AccountID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdatePassWord
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdatePassWord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdatePassWord, default initialized and not managed by a soap context
        virtual _ns1__UpdatePassWord *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdatePassWord); }
      public:
        /// Constructor with initializations
        _ns1__UpdatePassWord()
        {
          LoginName = (wchar_t *)0;
          PassWord = (wchar_t *)0;
          AccountID = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__UpdatePassWord() { }
        /// Friend allocator used by soap_new__ns1__UpdatePassWord(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdatePassWord * SOAP_FMAC2 soap_instantiate__ns1__UpdatePassWord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:337 */
#ifndef SOAP_TYPE__ns1__UpdatePassWordResponse
#define SOAP_TYPE__ns1__UpdatePassWordResponse (55)
/* complex XSD type 'ns1:UpdatePassWordResponse': */
class SOAP_CMAC _ns1__UpdatePassWordResponse {
      public:
        /// Optional element 'ns1:UpdatePassWordResult' of XSD type 'xsd:int'
        int *UpdatePassWordResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdatePassWordResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdatePassWordResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdatePassWordResponse, default initialized and not managed by a soap context
        virtual _ns1__UpdatePassWordResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdatePassWordResponse); }
      public:
        /// Constructor with initializations
        _ns1__UpdatePassWordResponse()
        {
          UpdatePassWordResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__UpdatePassWordResponse() { }
        /// Friend allocator used by soap_new__ns1__UpdatePassWordResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdatePassWordResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdatePassWordResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:340 */
#ifndef SOAP_TYPE__ns1__LoginCloud
#define SOAP_TYPE__ns1__LoginCloud (56)
/* complex XSD type 'ns1:LoginCloud': */
class SOAP_CMAC _ns1__LoginCloud {
      public:
        /// Optional element 'ns1:LoginName' of XSD type 'xsd:string'
        wchar_t *LoginName;
        /// Optional element 'ns1:PassWord' of XSD type 'xsd:string'
        wchar_t *PassWord;
        /// Optional element 'ns1:AccountID' of XSD type 'xsd:string'
        wchar_t *AccountID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LoginCloud
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LoginCloud; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LoginCloud, default initialized and not managed by a soap context
        virtual _ns1__LoginCloud *soap_alloc(void) const { return SOAP_NEW(_ns1__LoginCloud); }
      public:
        /// Constructor with initializations
        _ns1__LoginCloud()
        {
          LoginName = (wchar_t *)0;
          PassWord = (wchar_t *)0;
          AccountID = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LoginCloud() { }
        /// Friend allocator used by soap_new__ns1__LoginCloud(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LoginCloud * SOAP_FMAC2 soap_instantiate__ns1__LoginCloud(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:343 */
#ifndef SOAP_TYPE__ns1__LoginCloudResponse
#define SOAP_TYPE__ns1__LoginCloudResponse (57)
/* complex XSD type 'ns1:LoginCloudResponse': */
class SOAP_CMAC _ns1__LoginCloudResponse {
      public:
        /// Optional element 'ns1:LoginCloudResult' of XSD type 'xsd:int'
        int *LoginCloudResult;
        /// Optional element 'ns1:AccountID' of XSD type 'xsd:string'
        wchar_t *AccountID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LoginCloudResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LoginCloudResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LoginCloudResponse, default initialized and not managed by a soap context
        virtual _ns1__LoginCloudResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LoginCloudResponse); }
      public:
        /// Constructor with initializations
        _ns1__LoginCloudResponse()
        {
          LoginCloudResult = (int *)0;
          AccountID = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LoginCloudResponse() { }
        /// Friend allocator used by soap_new__ns1__LoginCloudResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LoginCloudResponse * SOAP_FMAC2 soap_instantiate__ns1__LoginCloudResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:346 */
#ifndef SOAP_TYPE__ns1__GetAccount
#define SOAP_TYPE__ns1__GetAccount (58)
/* complex XSD type 'ns1:GetAccount': */
class SOAP_CMAC _ns1__GetAccount {
      public:
        /// Optional element 'ns1:OptCode' of XSD type 'xsd:string'
        wchar_t *OptCode;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAccount
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAccount; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAccount, default initialized and not managed by a soap context
        virtual _ns1__GetAccount *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAccount); }
      public:
        /// Constructor with initializations
        _ns1__GetAccount()
        {
          OptCode = (wchar_t *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetAccount() { }
        /// Friend allocator used by soap_new__ns1__GetAccount(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAccount * SOAP_FMAC2 soap_instantiate__ns1__GetAccount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:349 */
#ifndef SOAP_TYPE__ns1__GetAccountResponse
#define SOAP_TYPE__ns1__GetAccountResponse (59)
/* complex XSD type 'ns1:GetAccountResponse': */
class SOAP_CMAC _ns1__GetAccountResponse {
      public:
        /// Optional element 'ns1:GetAccountResult' of XSD type 'ns2:ArrayOfPrimeAccount'
        ns2__ArrayOfPrimeAccount *GetAccountResult;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAccountResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAccountResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAccountResponse, default initialized and not managed by a soap context
        virtual _ns1__GetAccountResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAccountResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetAccountResponse()
        {
          GetAccountResult = (ns2__ArrayOfPrimeAccount *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetAccountResponse() { }
        /// Friend allocator used by soap_new__ns1__GetAccountResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAccountResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAccountResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:352 */
#ifndef SOAP_TYPE__ns1__SelectAccount
#define SOAP_TYPE__ns1__SelectAccount (60)
/* complex XSD type 'ns1:SelectAccount': */
class SOAP_CMAC _ns1__SelectAccount {
      public:
        /// Optional element 'ns1:OptCode' of XSD type 'xsd:string'
        wchar_t *OptCode;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SelectAccount
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SelectAccount; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SelectAccount, default initialized and not managed by a soap context
        virtual _ns1__SelectAccount *soap_alloc(void) const { return SOAP_NEW(_ns1__SelectAccount); }
      public:
        /// Constructor with initializations
        _ns1__SelectAccount()
        {
          OptCode = (wchar_t *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SelectAccount() { }
        /// Friend allocator used by soap_new__ns1__SelectAccount(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SelectAccount * SOAP_FMAC2 soap_instantiate__ns1__SelectAccount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:355 */
#ifndef SOAP_TYPE__ns1__SelectAccountResponse
#define SOAP_TYPE__ns1__SelectAccountResponse (61)
/* complex XSD type 'ns1:SelectAccountResponse': */
class SOAP_CMAC _ns1__SelectAccountResponse {
      public:
        /// Optional element 'ns1:SelectAccountResult' of XSD type 'xsd:string'
        wchar_t *SelectAccountResult;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SelectAccountResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SelectAccountResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SelectAccountResponse, default initialized and not managed by a soap context
        virtual _ns1__SelectAccountResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SelectAccountResponse); }
      public:
        /// Constructor with initializations
        _ns1__SelectAccountResponse()
        {
          SelectAccountResult = (wchar_t *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SelectAccountResponse() { }
        /// Friend allocator used by soap_new__ns1__SelectAccountResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SelectAccountResponse * SOAP_FMAC2 soap_instantiate__ns1__SelectAccountResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:358 */
#ifndef SOAP_TYPE__ns1__SetAccount
#define SOAP_TYPE__ns1__SetAccount (62)
/* complex XSD type 'ns1:SetAccount': */
class SOAP_CMAC _ns1__SetAccount {
      public:
        /// Optional element 'ns1:MyPrimeAccount' of XSD type 'ns2:PrimeAccount'
        ns2__PrimeAccount *MyPrimeAccount;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetAccount
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetAccount; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetAccount, default initialized and not managed by a soap context
        virtual _ns1__SetAccount *soap_alloc(void) const { return SOAP_NEW(_ns1__SetAccount); }
      public:
        /// Constructor with initializations
        _ns1__SetAccount()
        {
          MyPrimeAccount = (ns2__PrimeAccount *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetAccount() { }
        /// Friend allocator used by soap_new__ns1__SetAccount(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetAccount * SOAP_FMAC2 soap_instantiate__ns1__SetAccount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:361 */
#ifndef SOAP_TYPE__ns1__SetAccountResponse
#define SOAP_TYPE__ns1__SetAccountResponse (63)
/* complex XSD type 'ns1:SetAccountResponse': */
class SOAP_CMAC _ns1__SetAccountResponse {
      public:
        /// Optional element 'ns1:SetAccountResult' of XSD type 'xsd:int'
        int *SetAccountResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetAccountResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetAccountResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetAccountResponse, default initialized and not managed by a soap context
        virtual _ns1__SetAccountResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetAccountResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetAccountResponse()
        {
          SetAccountResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetAccountResponse() { }
        /// Friend allocator used by soap_new__ns1__SetAccountResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetAccountResponse * SOAP_FMAC2 soap_instantiate__ns1__SetAccountResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:364 */
#ifndef SOAP_TYPE__ns1__EditAccount
#define SOAP_TYPE__ns1__EditAccount (64)
/* complex XSD type 'ns1:EditAccount': */
class SOAP_CMAC _ns1__EditAccount {
      public:
        /// Optional element 'ns1:AccountID' of XSD type 'xsd:string'
        wchar_t *AccountID;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Optional element 'ns1:OptCode' of XSD type 'xsd:string'
        wchar_t *OptCode;
        /// Optional element 'ns1:ParaArray' of XSD type 'arr:ArrayOfstring'
        arr__ArrayOfstring *ParaArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__EditAccount
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__EditAccount; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__EditAccount, default initialized and not managed by a soap context
        virtual _ns1__EditAccount *soap_alloc(void) const { return SOAP_NEW(_ns1__EditAccount); }
      public:
        /// Constructor with initializations
        _ns1__EditAccount()
        {
          AccountID = (wchar_t *)0;
          FlagCode = (int *)0;
          OptCode = (wchar_t *)0;
          ParaArray = (arr__ArrayOfstring *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__EditAccount() { }
        /// Friend allocator used by soap_new__ns1__EditAccount(struct soap*, int)
        friend SOAP_FMAC1 _ns1__EditAccount * SOAP_FMAC2 soap_instantiate__ns1__EditAccount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:367 */
#ifndef SOAP_TYPE__ns1__EditAccountResponse
#define SOAP_TYPE__ns1__EditAccountResponse (65)
/* complex XSD type 'ns1:EditAccountResponse': */
class SOAP_CMAC _ns1__EditAccountResponse {
      public:
        /// Optional element 'ns1:EditAccountResult' of XSD type 'xsd:int'
        int *EditAccountResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__EditAccountResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__EditAccountResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__EditAccountResponse, default initialized and not managed by a soap context
        virtual _ns1__EditAccountResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__EditAccountResponse); }
      public:
        /// Constructor with initializations
        _ns1__EditAccountResponse()
        {
          EditAccountResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__EditAccountResponse() { }
        /// Friend allocator used by soap_new__ns1__EditAccountResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__EditAccountResponse * SOAP_FMAC2 soap_instantiate__ns1__EditAccountResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:370 */
#ifndef SOAP_TYPE__ns1__CreateDevice
#define SOAP_TYPE__ns1__CreateDevice (66)
/* complex XSD type 'ns1:CreateDevice': */
class SOAP_CMAC _ns1__CreateDevice {
      public:
        /// Optional element 'ns1:DeviceUUID' of XSD type 'xsd:string'
        wchar_t *DeviceUUID;
        /// Optional element 'ns1:ManangerID' of XSD type 'xsd:string'
        wchar_t *ManangerID;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateDevice
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateDevice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateDevice, default initialized and not managed by a soap context
        virtual _ns1__CreateDevice *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateDevice); }
      public:
        /// Constructor with initializations
        _ns1__CreateDevice()
        {
          DeviceUUID = (wchar_t *)0;
          ManangerID = (wchar_t *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateDevice() { }
        /// Friend allocator used by soap_new__ns1__CreateDevice(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateDevice * SOAP_FMAC2 soap_instantiate__ns1__CreateDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:373 */
#ifndef SOAP_TYPE__ns1__CreateDeviceResponse
#define SOAP_TYPE__ns1__CreateDeviceResponse (67)
/* complex XSD type 'ns1:CreateDeviceResponse': */
class SOAP_CMAC _ns1__CreateDeviceResponse {
      public:
        /// Optional element 'ns1:CreateDeviceResult' of XSD type 'xsd:int'
        int *CreateDeviceResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateDeviceResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateDeviceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateDeviceResponse, default initialized and not managed by a soap context
        virtual _ns1__CreateDeviceResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateDeviceResponse); }
      public:
        /// Constructor with initializations
        _ns1__CreateDeviceResponse()
        {
          CreateDeviceResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateDeviceResponse() { }
        /// Friend allocator used by soap_new__ns1__CreateDeviceResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateDeviceResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateDeviceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:376 */
#ifndef SOAP_TYPE__ns1__MadeDevice
#define SOAP_TYPE__ns1__MadeDevice (68)
/* complex XSD type 'ns1:MadeDevice': */
class SOAP_CMAC _ns1__MadeDevice {
      public:
        /// Optional element 'ns1:DeviceID' of XSD type 'xsd:string'
        wchar_t *DeviceID;
        /// Optional element 'ns1:ManangerID' of XSD type 'xsd:string'
        wchar_t *ManangerID;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__MadeDevice
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__MadeDevice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__MadeDevice, default initialized and not managed by a soap context
        virtual _ns1__MadeDevice *soap_alloc(void) const { return SOAP_NEW(_ns1__MadeDevice); }
      public:
        /// Constructor with initializations
        _ns1__MadeDevice()
        {
          DeviceID = (wchar_t *)0;
          ManangerID = (wchar_t *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__MadeDevice() { }
        /// Friend allocator used by soap_new__ns1__MadeDevice(struct soap*, int)
        friend SOAP_FMAC1 _ns1__MadeDevice * SOAP_FMAC2 soap_instantiate__ns1__MadeDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:379 */
#ifndef SOAP_TYPE__ns1__MadeDeviceResponse
#define SOAP_TYPE__ns1__MadeDeviceResponse (69)
/* complex XSD type 'ns1:MadeDeviceResponse': */
class SOAP_CMAC _ns1__MadeDeviceResponse {
      public:
        /// Optional element 'ns1:MadeDeviceResult' of XSD type 'xsd:int'
        int *MadeDeviceResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__MadeDeviceResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__MadeDeviceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__MadeDeviceResponse, default initialized and not managed by a soap context
        virtual _ns1__MadeDeviceResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__MadeDeviceResponse); }
      public:
        /// Constructor with initializations
        _ns1__MadeDeviceResponse()
        {
          MadeDeviceResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__MadeDeviceResponse() { }
        /// Friend allocator used by soap_new__ns1__MadeDeviceResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__MadeDeviceResponse * SOAP_FMAC2 soap_instantiate__ns1__MadeDeviceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:382 */
#ifndef SOAP_TYPE__ns1__SaleDevice
#define SOAP_TYPE__ns1__SaleDevice (70)
/* complex XSD type 'ns1:SaleDevice': */
class SOAP_CMAC _ns1__SaleDevice {
      public:
        /// Optional element 'ns1:DeviceID' of XSD type 'xsd:string'
        wchar_t *DeviceID;
        /// Optional element 'ns1:AgenFromID' of XSD type 'xsd:string'
        wchar_t *AgenFromID;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SaleDevice
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SaleDevice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SaleDevice, default initialized and not managed by a soap context
        virtual _ns1__SaleDevice *soap_alloc(void) const { return SOAP_NEW(_ns1__SaleDevice); }
      public:
        /// Constructor with initializations
        _ns1__SaleDevice()
        {
          DeviceID = (wchar_t *)0;
          AgenFromID = (wchar_t *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SaleDevice() { }
        /// Friend allocator used by soap_new__ns1__SaleDevice(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SaleDevice * SOAP_FMAC2 soap_instantiate__ns1__SaleDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:385 */
#ifndef SOAP_TYPE__ns1__SaleDeviceResponse
#define SOAP_TYPE__ns1__SaleDeviceResponse (71)
/* complex XSD type 'ns1:SaleDeviceResponse': */
class SOAP_CMAC _ns1__SaleDeviceResponse {
      public:
        /// Optional element 'ns1:SaleDeviceResult' of XSD type 'xsd:int'
        int *SaleDeviceResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SaleDeviceResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SaleDeviceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SaleDeviceResponse, default initialized and not managed by a soap context
        virtual _ns1__SaleDeviceResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SaleDeviceResponse); }
      public:
        /// Constructor with initializations
        _ns1__SaleDeviceResponse()
        {
          SaleDeviceResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SaleDeviceResponse() { }
        /// Friend allocator used by soap_new__ns1__SaleDeviceResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SaleDeviceResponse * SOAP_FMAC2 soap_instantiate__ns1__SaleDeviceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:388 */
#ifndef SOAP_TYPE__ns1__BindingDevice
#define SOAP_TYPE__ns1__BindingDevice (72)
/* complex XSD type 'ns1:BindingDevice': */
class SOAP_CMAC _ns1__BindingDevice {
      public:
        /// Optional element 'ns1:DeviceID' of XSD type 'xsd:string'
        wchar_t *DeviceID;
        /// Optional element 'ns1:AccountID' of XSD type 'xsd:string'
        wchar_t *AccountID;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BindingDevice
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BindingDevice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BindingDevice, default initialized and not managed by a soap context
        virtual _ns1__BindingDevice *soap_alloc(void) const { return SOAP_NEW(_ns1__BindingDevice); }
      public:
        /// Constructor with initializations
        _ns1__BindingDevice()
        {
          DeviceID = (wchar_t *)0;
          AccountID = (wchar_t *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__BindingDevice() { }
        /// Friend allocator used by soap_new__ns1__BindingDevice(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BindingDevice * SOAP_FMAC2 soap_instantiate__ns1__BindingDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:391 */
#ifndef SOAP_TYPE__ns1__BindingDeviceResponse
#define SOAP_TYPE__ns1__BindingDeviceResponse (73)
/* complex XSD type 'ns1:BindingDeviceResponse': */
class SOAP_CMAC _ns1__BindingDeviceResponse {
      public:
        /// Optional element 'ns1:BindingDeviceResult' of XSD type 'xsd:int'
        int *BindingDeviceResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BindingDeviceResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BindingDeviceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BindingDeviceResponse, default initialized and not managed by a soap context
        virtual _ns1__BindingDeviceResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__BindingDeviceResponse); }
      public:
        /// Constructor with initializations
        _ns1__BindingDeviceResponse()
        {
          BindingDeviceResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__BindingDeviceResponse() { }
        /// Friend allocator used by soap_new__ns1__BindingDeviceResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BindingDeviceResponse * SOAP_FMAC2 soap_instantiate__ns1__BindingDeviceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:394 */
#ifndef SOAP_TYPE__ns1__GetDevice
#define SOAP_TYPE__ns1__GetDevice (74)
/* complex XSD type 'ns1:GetDevice': */
class SOAP_CMAC _ns1__GetDevice {
      public:
        /// Optional element 'ns1:OptCode' of XSD type 'xsd:string'
        wchar_t *OptCode;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDevice
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDevice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDevice, default initialized and not managed by a soap context
        virtual _ns1__GetDevice *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDevice); }
      public:
        /// Constructor with initializations
        _ns1__GetDevice()
        {
          OptCode = (wchar_t *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDevice() { }
        /// Friend allocator used by soap_new__ns1__GetDevice(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDevice * SOAP_FMAC2 soap_instantiate__ns1__GetDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:397 */
#ifndef SOAP_TYPE__ns1__GetDeviceResponse
#define SOAP_TYPE__ns1__GetDeviceResponse (75)
/* complex XSD type 'ns1:GetDeviceResponse': */
class SOAP_CMAC _ns1__GetDeviceResponse {
      public:
        /// Optional element 'ns1:GetDeviceResult' of XSD type 'xsd:string'
        wchar_t *GetDeviceResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDeviceResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetDeviceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDeviceResponse, default initialized and not managed by a soap context
        virtual _ns1__GetDeviceResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetDeviceResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetDeviceResponse()
        {
          GetDeviceResult = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetDeviceResponse() { }
        /// Friend allocator used by soap_new__ns1__GetDeviceResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDeviceResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDeviceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:400 */
#ifndef SOAP_TYPE__ns1__SendSmartWarn
#define SOAP_TYPE__ns1__SendSmartWarn (76)
/* complex XSD type 'ns1:SendSmartWarn': */
class SOAP_CMAC _ns1__SendSmartWarn {
      public:
        /// Optional element 'ns1:SmartWarn' of XSD type 'xsd:string'
        wchar_t *SmartWarn;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SendSmartWarn
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SendSmartWarn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SendSmartWarn, default initialized and not managed by a soap context
        virtual _ns1__SendSmartWarn *soap_alloc(void) const { return SOAP_NEW(_ns1__SendSmartWarn); }
      public:
        /// Constructor with initializations
        _ns1__SendSmartWarn()
        {
          SmartWarn = (wchar_t *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SendSmartWarn() { }
        /// Friend allocator used by soap_new__ns1__SendSmartWarn(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SendSmartWarn * SOAP_FMAC2 soap_instantiate__ns1__SendSmartWarn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:403 */
#ifndef SOAP_TYPE__ns1__SendSmartWarnResponse
#define SOAP_TYPE__ns1__SendSmartWarnResponse (77)
/* complex XSD type 'ns1:SendSmartWarnResponse': */
class SOAP_CMAC _ns1__SendSmartWarnResponse {
      public:
        /// Optional element 'ns1:SendSmartWarnResult' of XSD type 'xsd:int'
        int *SendSmartWarnResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SendSmartWarnResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SendSmartWarnResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SendSmartWarnResponse, default initialized and not managed by a soap context
        virtual _ns1__SendSmartWarnResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SendSmartWarnResponse); }
      public:
        /// Constructor with initializations
        _ns1__SendSmartWarnResponse()
        {
          SendSmartWarnResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SendSmartWarnResponse() { }
        /// Friend allocator used by soap_new__ns1__SendSmartWarnResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SendSmartWarnResponse * SOAP_FMAC2 soap_instantiate__ns1__SendSmartWarnResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:406 */
#ifndef SOAP_TYPE__ns1__PostListSmartWarn
#define SOAP_TYPE__ns1__PostListSmartWarn (78)
/* complex XSD type 'ns1:PostListSmartWarn': */
class SOAP_CMAC _ns1__PostListSmartWarn {
      public:
        /// Optional element 'ns1:SmartWarnSet' of XSD type 'xsd:string'
        wchar_t *SmartWarnSet;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PostListSmartWarn
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__PostListSmartWarn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PostListSmartWarn, default initialized and not managed by a soap context
        virtual _ns1__PostListSmartWarn *soap_alloc(void) const { return SOAP_NEW(_ns1__PostListSmartWarn); }
      public:
        /// Constructor with initializations
        _ns1__PostListSmartWarn()
        {
          SmartWarnSet = (wchar_t *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__PostListSmartWarn() { }
        /// Friend allocator used by soap_new__ns1__PostListSmartWarn(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PostListSmartWarn * SOAP_FMAC2 soap_instantiate__ns1__PostListSmartWarn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:409 */
#ifndef SOAP_TYPE__ns1__PostListSmartWarnResponse
#define SOAP_TYPE__ns1__PostListSmartWarnResponse (79)
/* complex XSD type 'ns1:PostListSmartWarnResponse': */
class SOAP_CMAC _ns1__PostListSmartWarnResponse {
      public:
        /// Optional element 'ns1:PostListSmartWarnResult' of XSD type 'xsd:int'
        int *PostListSmartWarnResult;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PostListSmartWarnResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__PostListSmartWarnResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PostListSmartWarnResponse, default initialized and not managed by a soap context
        virtual _ns1__PostListSmartWarnResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__PostListSmartWarnResponse); }
      public:
        /// Constructor with initializations
        _ns1__PostListSmartWarnResponse()
        {
          PostListSmartWarnResult = (int *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__PostListSmartWarnResponse() { }
        /// Friend allocator used by soap_new__ns1__PostListSmartWarnResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PostListSmartWarnResponse * SOAP_FMAC2 soap_instantiate__ns1__PostListSmartWarnResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:412 */
#ifndef SOAP_TYPE__ns1__GetSmartWarn
#define SOAP_TYPE__ns1__GetSmartWarn (80)
/* complex XSD type 'ns1:GetSmartWarn': */
class SOAP_CMAC _ns1__GetSmartWarn {
      public:
        /// Optional element 'ns1:OptCode' of XSD type 'xsd:string'
        wchar_t *OptCode;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Optional element 'ns1:SmartWarnList' of XSD type 'xsd:string'
        wchar_t *SmartWarnList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSmartWarn
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSmartWarn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSmartWarn, default initialized and not managed by a soap context
        virtual _ns1__GetSmartWarn *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSmartWarn); }
      public:
        /// Constructor with initializations
        _ns1__GetSmartWarn()
        {
          OptCode = (wchar_t *)0;
          FlagCode = (int *)0;
          SmartWarnList = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSmartWarn() { }
        /// Friend allocator used by soap_new__ns1__GetSmartWarn(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSmartWarn * SOAP_FMAC2 soap_instantiate__ns1__GetSmartWarn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:415 */
#ifndef SOAP_TYPE__ns1__GetSmartWarnResponse
#define SOAP_TYPE__ns1__GetSmartWarnResponse (81)
/* complex XSD type 'ns1:GetSmartWarnResponse': */
class SOAP_CMAC _ns1__GetSmartWarnResponse {
      public:
        /// Optional element 'ns1:GetSmartWarnResult' of XSD type 'xsd:int'
        int *GetSmartWarnResult;
        /// Optional element 'ns1:SmartWarnList' of XSD type 'xsd:string'
        wchar_t *SmartWarnList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSmartWarnResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSmartWarnResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSmartWarnResponse, default initialized and not managed by a soap context
        virtual _ns1__GetSmartWarnResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSmartWarnResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetSmartWarnResponse()
        {
          GetSmartWarnResult = (int *)0;
          SmartWarnList = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSmartWarnResponse() { }
        /// Friend allocator used by soap_new__ns1__GetSmartWarnResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSmartWarnResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSmartWarnResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:418 */
#ifndef SOAP_TYPE__ns1__TotalSmartWarn
#define SOAP_TYPE__ns1__TotalSmartWarn (82)
/* complex XSD type 'ns1:TotalSmartWarn': */
class SOAP_CMAC _ns1__TotalSmartWarn {
      public:
        /// Optional element 'ns1:OptCode' of XSD type 'xsd:string'
        wchar_t *OptCode;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Optional element 'ns1:TotalSmartWarn' of XSD type 'xsd:string'
        wchar_t *TotalSmartWarn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__TotalSmartWarn
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__TotalSmartWarn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__TotalSmartWarn, default initialized and not managed by a soap context
        virtual _ns1__TotalSmartWarn *soap_alloc(void) const { return SOAP_NEW(_ns1__TotalSmartWarn); }
      public:
        /// Constructor with initializations
        _ns1__TotalSmartWarn()
        {
          OptCode = (wchar_t *)0;
          FlagCode = (int *)0;
          TotalSmartWarn = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__TotalSmartWarn() { }
        /// Friend allocator used by soap_new__ns1__TotalSmartWarn(struct soap*, int)
        friend SOAP_FMAC1 _ns1__TotalSmartWarn * SOAP_FMAC2 soap_instantiate__ns1__TotalSmartWarn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:421 */
#ifndef SOAP_TYPE__ns1__TotalSmartWarnResponse
#define SOAP_TYPE__ns1__TotalSmartWarnResponse (83)
/* complex XSD type 'ns1:TotalSmartWarnResponse': */
class SOAP_CMAC _ns1__TotalSmartWarnResponse {
      public:
        /// Optional element 'ns1:TotalSmartWarnResult' of XSD type 'xsd:int'
        int *TotalSmartWarnResult;
        /// Optional element 'ns1:TotalSmartWarn' of XSD type 'xsd:string'
        wchar_t *TotalSmartWarn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__TotalSmartWarnResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__TotalSmartWarnResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__TotalSmartWarnResponse, default initialized and not managed by a soap context
        virtual _ns1__TotalSmartWarnResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__TotalSmartWarnResponse); }
      public:
        /// Constructor with initializations
        _ns1__TotalSmartWarnResponse()
        {
          TotalSmartWarnResult = (int *)0;
          TotalSmartWarn = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__TotalSmartWarnResponse() { }
        /// Friend allocator used by soap_new__ns1__TotalSmartWarnResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__TotalSmartWarnResponse * SOAP_FMAC2 soap_instantiate__ns1__TotalSmartWarnResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:424 */
#ifndef SOAP_TYPE__ns1__SendCarRunState
#define SOAP_TYPE__ns1__SendCarRunState (84)
/* complex XSD type 'ns1:SendCarRunState': */
class SOAP_CMAC _ns1__SendCarRunState {
      public:
        /// Optional element 'ns1:CarRunState' of XSD type 'xsd:string'
        wchar_t *CarRunState;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SendCarRunState
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SendCarRunState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SendCarRunState, default initialized and not managed by a soap context
        virtual _ns1__SendCarRunState *soap_alloc(void) const { return SOAP_NEW(_ns1__SendCarRunState); }
      public:
        /// Constructor with initializations
        _ns1__SendCarRunState()
        {
          CarRunState = (wchar_t *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SendCarRunState() { }
        /// Friend allocator used by soap_new__ns1__SendCarRunState(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SendCarRunState * SOAP_FMAC2 soap_instantiate__ns1__SendCarRunState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:427 */
#ifndef SOAP_TYPE__ns1__SendCarRunStateResponse
#define SOAP_TYPE__ns1__SendCarRunStateResponse (85)
/* complex XSD type 'ns1:SendCarRunStateResponse': */
class SOAP_CMAC _ns1__SendCarRunStateResponse {
      public:
        /// Optional element 'ns1:SendCarRunStateResult' of XSD type 'xsd:int'
        int *SendCarRunStateResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SendCarRunStateResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SendCarRunStateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SendCarRunStateResponse, default initialized and not managed by a soap context
        virtual _ns1__SendCarRunStateResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SendCarRunStateResponse); }
      public:
        /// Constructor with initializations
        _ns1__SendCarRunStateResponse()
        {
          SendCarRunStateResult = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SendCarRunStateResponse() { }
        /// Friend allocator used by soap_new__ns1__SendCarRunStateResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SendCarRunStateResponse * SOAP_FMAC2 soap_instantiate__ns1__SendCarRunStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:430 */
#ifndef SOAP_TYPE__ns1__PostListCarRunState
#define SOAP_TYPE__ns1__PostListCarRunState (86)
/* complex XSD type 'ns1:PostListCarRunState': */
class SOAP_CMAC _ns1__PostListCarRunState {
      public:
        /// Optional element 'ns1:CarRunStateSet' of XSD type 'xsd:string'
        wchar_t *CarRunStateSet;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PostListCarRunState
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__PostListCarRunState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PostListCarRunState, default initialized and not managed by a soap context
        virtual _ns1__PostListCarRunState *soap_alloc(void) const { return SOAP_NEW(_ns1__PostListCarRunState); }
      public:
        /// Constructor with initializations
        _ns1__PostListCarRunState()
        {
          CarRunStateSet = (wchar_t *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__PostListCarRunState() { }
        /// Friend allocator used by soap_new__ns1__PostListCarRunState(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PostListCarRunState * SOAP_FMAC2 soap_instantiate__ns1__PostListCarRunState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:433 */
#ifndef SOAP_TYPE__ns1__PostListCarRunStateResponse
#define SOAP_TYPE__ns1__PostListCarRunStateResponse (87)
/* complex XSD type 'ns1:PostListCarRunStateResponse': */
class SOAP_CMAC _ns1__PostListCarRunStateResponse {
      public:
        /// Optional element 'ns1:PostListCarRunStateResult' of XSD type 'xsd:int'
        int *PostListCarRunStateResult;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PostListCarRunStateResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__PostListCarRunStateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PostListCarRunStateResponse, default initialized and not managed by a soap context
        virtual _ns1__PostListCarRunStateResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__PostListCarRunStateResponse); }
      public:
        /// Constructor with initializations
        _ns1__PostListCarRunStateResponse()
        {
          PostListCarRunStateResult = (int *)0;
          FlagCode = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__PostListCarRunStateResponse() { }
        /// Friend allocator used by soap_new__ns1__PostListCarRunStateResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PostListCarRunStateResponse * SOAP_FMAC2 soap_instantiate__ns1__PostListCarRunStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:436 */
#ifndef SOAP_TYPE__ns1__GetCarRunState
#define SOAP_TYPE__ns1__GetCarRunState (88)
/* complex XSD type 'ns1:GetCarRunState': */
class SOAP_CMAC _ns1__GetCarRunState {
      public:
        /// Optional element 'ns1:OptCode' of XSD type 'xsd:string'
        wchar_t *OptCode;
        /// Optional element 'ns1:FlagCode' of XSD type 'xsd:int'
        int *FlagCode;
        /// Optional element 'ns1:CarRunStateList' of XSD type 'xsd:string'
        wchar_t *CarRunStateList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCarRunState
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCarRunState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCarRunState, default initialized and not managed by a soap context
        virtual _ns1__GetCarRunState *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCarRunState); }
      public:
        /// Constructor with initializations
        _ns1__GetCarRunState()
        {
          OptCode = (wchar_t *)0;
          FlagCode = (int *)0;
          CarRunStateList = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCarRunState() { }
        /// Friend allocator used by soap_new__ns1__GetCarRunState(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCarRunState * SOAP_FMAC2 soap_instantiate__ns1__GetCarRunState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:439 */
#ifndef SOAP_TYPE__ns1__GetCarRunStateResponse
#define SOAP_TYPE__ns1__GetCarRunStateResponse (89)
/* complex XSD type 'ns1:GetCarRunStateResponse': */
class SOAP_CMAC _ns1__GetCarRunStateResponse {
      public:
        /// Optional element 'ns1:GetCarRunStateResult' of XSD type 'xsd:int'
        int *GetCarRunStateResult;
        /// Optional element 'ns1:CarRunStateList' of XSD type 'xsd:string'
        wchar_t *CarRunStateList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCarRunStateResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCarRunStateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCarRunStateResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCarRunStateResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCarRunStateResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCarRunStateResponse()
        {
          GetCarRunStateResult = (int *)0;
          CarRunStateList = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCarRunStateResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCarRunStateResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCarRunStateResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCarRunStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:442 */
#ifndef SOAP_TYPE_ns2__ArrayOfPrimeAccount
#define SOAP_TYPE_ns2__ArrayOfPrimeAccount (90)
/* Type ns2__ArrayOfPrimeAccount is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:ArrayOfPrimeAccount': */
class SOAP_CMAC ns2__ArrayOfPrimeAccount : public xsd__anyType {
      public:
        /// Sequence of elements 'ns2:PrimeAccount' of XSD type 'ns2:PrimeAccount' stored in dynamic array PrimeAccount of length __sizePrimeAccount
        int __sizePrimeAccount;
        ns2__PrimeAccount **PrimeAccount;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ArrayOfPrimeAccount
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ArrayOfPrimeAccount; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ArrayOfPrimeAccount, default initialized and not managed by a soap context
        virtual ns2__ArrayOfPrimeAccount *soap_alloc(void) const { return SOAP_NEW(ns2__ArrayOfPrimeAccount); }
      public:
        /// Constructor with initializations
        ns2__ArrayOfPrimeAccount()
        {
          __sizePrimeAccount = 0;
          PrimeAccount = NULL;
        }
        virtual ~ns2__ArrayOfPrimeAccount() { }
        /// Friend allocator used by soap_new_ns2__ArrayOfPrimeAccount(struct soap*, int)
        friend SOAP_FMAC1 ns2__ArrayOfPrimeAccount * SOAP_FMAC2 soap_instantiate_ns2__ArrayOfPrimeAccount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:445 */
#ifndef SOAP_TYPE_ns2__PrimeAccount
#define SOAP_TYPE_ns2__PrimeAccount (91)
/* Type ns2__PrimeAccount is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:PrimeAccount': */
class SOAP_CMAC ns2__PrimeAccount : public xsd__anyType {
      public:
        /// Optional element 'ns2:AccountID' of XSD type 'xsd:string'
        wchar_t *AccountID;
        /// Optional element 'ns2:ActivityLess' of XSD type 'xsd:int'
        int *ActivityLess;
        /// Optional element 'ns2:Address' of XSD type 'xsd:string'
        wchar_t *Address;
        /// Optional element 'ns2:BirthDate' of XSD type 'xsd:dateTime'
        time_t *BirthDate;
        /// Optional element 'ns2:EMail' of XSD type 'xsd:string'
        wchar_t *EMail;
        /// Optional element 'ns2:HeadImage' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *HeadImage;
        /// Optional element 'ns2:Job' of XSD type 'xsd:string'
        wchar_t *Job;
        /// Optional element 'ns2:LastDate' of XSD type 'xsd:dateTime'
        time_t *LastDate;
        /// Optional element 'ns2:LoginName' of XSD type 'xsd:string'
        wchar_t *LoginName;
        /// Optional element 'ns2:MobileID' of XSD type 'xsd:string'
        wchar_t *MobileID;
        /// Optional element 'ns2:NickName' of XSD type 'xsd:string'
        wchar_t *NickName;
        /// Optional element 'ns2:OwnerName' of XSD type 'xsd:string'
        wchar_t *OwnerName;
        /// Optional element 'ns2:PassWord' of XSD type 'xsd:string'
        wchar_t *PassWord;
        /// Optional element 'ns2:PersonID' of XSD type 'xsd:string'
        wchar_t *PersonID;
        /// Optional element 'ns2:RegDate' of XSD type 'xsd:dateTime'
        time_t *RegDate;
        /// Optional element 'ns2:SexID' of XSD type 'xsd:int'
        int *SexID;
        /// Optional element 'ns2:Signature' of XSD type 'xsd:string'
        wchar_t *Signature;
        /// Optional element 'ns2:TeleCode' of XSD type 'xsd:string'
        wchar_t *TeleCode;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PrimeAccount
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PrimeAccount; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PrimeAccount, default initialized and not managed by a soap context
        virtual ns2__PrimeAccount *soap_alloc(void) const { return SOAP_NEW(ns2__PrimeAccount); }
      public:
        /// Constructor with initializations
        ns2__PrimeAccount()
        {
          AccountID = (wchar_t *)0;
          ActivityLess = (int *)0;
          Address = (wchar_t *)0;
          BirthDate = (time_t *)0;
          EMail = (wchar_t *)0;
          HeadImage = (xsd__base64Binary *)0;
          Job = (wchar_t *)0;
          LastDate = (time_t *)0;
          LoginName = (wchar_t *)0;
          MobileID = (wchar_t *)0;
          NickName = (wchar_t *)0;
          OwnerName = (wchar_t *)0;
          PassWord = (wchar_t *)0;
          PersonID = (wchar_t *)0;
          RegDate = (time_t *)0;
          SexID = (int *)0;
          Signature = (wchar_t *)0;
          TeleCode = (wchar_t *)0;
        }
        virtual ~ns2__PrimeAccount() { }
        /// Friend allocator used by soap_new_ns2__PrimeAccount(struct soap*, int)
        friend SOAP_FMAC1 ns2__PrimeAccount * SOAP_FMAC2 soap_instantiate_ns2__PrimeAccount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:448 */
#ifndef SOAP_TYPE_arr__ArrayOfstring
#define SOAP_TYPE_arr__ArrayOfstring (92)
/* Type arr__ArrayOfstring is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'arr:ArrayOfstring': */
class SOAP_CMAC arr__ArrayOfstring : public xsd__anyType {
      public:
        /// Sequence of elements 'arr:string' of XSD type 'xsd:string' stored in dynamic array string of length __sizestring
        int __sizestring;
        std::wstring *string;
      public:
        /// Return unique type id SOAP_TYPE_arr__ArrayOfstring
        virtual int soap_type(void) const { return SOAP_TYPE_arr__ArrayOfstring; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type arr__ArrayOfstring, default initialized and not managed by a soap context
        virtual arr__ArrayOfstring *soap_alloc(void) const { return SOAP_NEW(arr__ArrayOfstring); }
      public:
        /// Constructor with initializations
        arr__ArrayOfstring()
        {
          __sizestring = 0;
          string = NULL;
        }
        virtual ~arr__ArrayOfstring() { }
        /// Friend allocator used by soap_new_arr__ArrayOfstring(struct soap*, int)
        friend SOAP_FMAC1 arr__ArrayOfstring * SOAP_FMAC2 soap_instantiate_arr__ArrayOfstring(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:1806 */
#ifndef SOAP_TYPE___ns1__RegisterAccount
#define SOAP_TYPE___ns1__RegisterAccount (106)
/* Wrapper: */
struct __ns1__RegisterAccount {
      public:
        /** Optional element 'ns1:RegisterAccount' of XSD type 'ns1:RegisterAccount' */
        _ns1__RegisterAccount *ns1__RegisterAccount;
      public:
        /** Return unique type id SOAP_TYPE___ns1__RegisterAccount */
        int soap_type() const { return SOAP_TYPE___ns1__RegisterAccount; }
        /** Constructor with member initializations */
        __ns1__RegisterAccount()
        {
          ns1__RegisterAccount = (_ns1__RegisterAccount *)0;
        }
        /** Friend allocator used by soap_new___ns1__RegisterAccount(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__RegisterAccount * SOAP_FMAC2 soap_instantiate___ns1__RegisterAccount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:1879 */
#ifndef SOAP_TYPE___ns1__UpdatePassWord
#define SOAP_TYPE___ns1__UpdatePassWord (110)
/* Wrapper: */
struct __ns1__UpdatePassWord {
      public:
        /** Optional element 'ns1:UpdatePassWord' of XSD type 'ns1:UpdatePassWord' */
        _ns1__UpdatePassWord *ns1__UpdatePassWord;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UpdatePassWord */
        int soap_type() const { return SOAP_TYPE___ns1__UpdatePassWord; }
        /** Constructor with member initializations */
        __ns1__UpdatePassWord()
        {
          ns1__UpdatePassWord = (_ns1__UpdatePassWord *)0;
        }
        /** Friend allocator used by soap_new___ns1__UpdatePassWord(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__UpdatePassWord * SOAP_FMAC2 soap_instantiate___ns1__UpdatePassWord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:1952 */
#ifndef SOAP_TYPE___ns1__LoginCloud
#define SOAP_TYPE___ns1__LoginCloud (114)
/* Wrapper: */
struct __ns1__LoginCloud {
      public:
        /** Optional element 'ns1:LoginCloud' of XSD type 'ns1:LoginCloud' */
        _ns1__LoginCloud *ns1__LoginCloud;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LoginCloud */
        int soap_type() const { return SOAP_TYPE___ns1__LoginCloud; }
        /** Constructor with member initializations */
        __ns1__LoginCloud()
        {
          ns1__LoginCloud = (_ns1__LoginCloud *)0;
        }
        /** Friend allocator used by soap_new___ns1__LoginCloud(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__LoginCloud * SOAP_FMAC2 soap_instantiate___ns1__LoginCloud(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2025 */
#ifndef SOAP_TYPE___ns1__GetAccount
#define SOAP_TYPE___ns1__GetAccount (118)
/* Wrapper: */
struct __ns1__GetAccount {
      public:
        /** Optional element 'ns1:GetAccount' of XSD type 'ns1:GetAccount' */
        _ns1__GetAccount *ns1__GetAccount;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetAccount */
        int soap_type() const { return SOAP_TYPE___ns1__GetAccount; }
        /** Constructor with member initializations */
        __ns1__GetAccount()
        {
          ns1__GetAccount = (_ns1__GetAccount *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetAccount(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetAccount * SOAP_FMAC2 soap_instantiate___ns1__GetAccount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2098 */
#ifndef SOAP_TYPE___ns1__SelectAccount
#define SOAP_TYPE___ns1__SelectAccount (122)
/* Wrapper: */
struct __ns1__SelectAccount {
      public:
        /** Optional element 'ns1:SelectAccount' of XSD type 'ns1:SelectAccount' */
        _ns1__SelectAccount *ns1__SelectAccount;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SelectAccount */
        int soap_type() const { return SOAP_TYPE___ns1__SelectAccount; }
        /** Constructor with member initializations */
        __ns1__SelectAccount()
        {
          ns1__SelectAccount = (_ns1__SelectAccount *)0;
        }
        /** Friend allocator used by soap_new___ns1__SelectAccount(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SelectAccount * SOAP_FMAC2 soap_instantiate___ns1__SelectAccount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2171 */
#ifndef SOAP_TYPE___ns1__SetAccount
#define SOAP_TYPE___ns1__SetAccount (126)
/* Wrapper: */
struct __ns1__SetAccount {
      public:
        /** Optional element 'ns1:SetAccount' of XSD type 'ns1:SetAccount' */
        _ns1__SetAccount *ns1__SetAccount;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetAccount */
        int soap_type() const { return SOAP_TYPE___ns1__SetAccount; }
        /** Constructor with member initializations */
        __ns1__SetAccount()
        {
          ns1__SetAccount = (_ns1__SetAccount *)0;
        }
        /** Friend allocator used by soap_new___ns1__SetAccount(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SetAccount * SOAP_FMAC2 soap_instantiate___ns1__SetAccount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2244 */
#ifndef SOAP_TYPE___ns1__EditAccount
#define SOAP_TYPE___ns1__EditAccount (130)
/* Wrapper: */
struct __ns1__EditAccount {
      public:
        /** Optional element 'ns1:EditAccount' of XSD type 'ns1:EditAccount' */
        _ns1__EditAccount *ns1__EditAccount;
      public:
        /** Return unique type id SOAP_TYPE___ns1__EditAccount */
        int soap_type() const { return SOAP_TYPE___ns1__EditAccount; }
        /** Constructor with member initializations */
        __ns1__EditAccount()
        {
          ns1__EditAccount = (_ns1__EditAccount *)0;
        }
        /** Friend allocator used by soap_new___ns1__EditAccount(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__EditAccount * SOAP_FMAC2 soap_instantiate___ns1__EditAccount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2317 */
#ifndef SOAP_TYPE___ns1__CreateDevice
#define SOAP_TYPE___ns1__CreateDevice (134)
/* Wrapper: */
struct __ns1__CreateDevice {
      public:
        /** Optional element 'ns1:CreateDevice' of XSD type 'ns1:CreateDevice' */
        _ns1__CreateDevice *ns1__CreateDevice;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CreateDevice */
        int soap_type() const { return SOAP_TYPE___ns1__CreateDevice; }
        /** Constructor with member initializations */
        __ns1__CreateDevice()
        {
          ns1__CreateDevice = (_ns1__CreateDevice *)0;
        }
        /** Friend allocator used by soap_new___ns1__CreateDevice(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CreateDevice * SOAP_FMAC2 soap_instantiate___ns1__CreateDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2390 */
#ifndef SOAP_TYPE___ns1__MadeDevice
#define SOAP_TYPE___ns1__MadeDevice (138)
/* Wrapper: */
struct __ns1__MadeDevice {
      public:
        /** Optional element 'ns1:MadeDevice' of XSD type 'ns1:MadeDevice' */
        _ns1__MadeDevice *ns1__MadeDevice;
      public:
        /** Return unique type id SOAP_TYPE___ns1__MadeDevice */
        int soap_type() const { return SOAP_TYPE___ns1__MadeDevice; }
        /** Constructor with member initializations */
        __ns1__MadeDevice()
        {
          ns1__MadeDevice = (_ns1__MadeDevice *)0;
        }
        /** Friend allocator used by soap_new___ns1__MadeDevice(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__MadeDevice * SOAP_FMAC2 soap_instantiate___ns1__MadeDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2463 */
#ifndef SOAP_TYPE___ns1__SaleDevice
#define SOAP_TYPE___ns1__SaleDevice (142)
/* Wrapper: */
struct __ns1__SaleDevice {
      public:
        /** Optional element 'ns1:SaleDevice' of XSD type 'ns1:SaleDevice' */
        _ns1__SaleDevice *ns1__SaleDevice;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SaleDevice */
        int soap_type() const { return SOAP_TYPE___ns1__SaleDevice; }
        /** Constructor with member initializations */
        __ns1__SaleDevice()
        {
          ns1__SaleDevice = (_ns1__SaleDevice *)0;
        }
        /** Friend allocator used by soap_new___ns1__SaleDevice(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SaleDevice * SOAP_FMAC2 soap_instantiate___ns1__SaleDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2536 */
#ifndef SOAP_TYPE___ns1__BindingDevice
#define SOAP_TYPE___ns1__BindingDevice (146)
/* Wrapper: */
struct __ns1__BindingDevice {
      public:
        /** Optional element 'ns1:BindingDevice' of XSD type 'ns1:BindingDevice' */
        _ns1__BindingDevice *ns1__BindingDevice;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BindingDevice */
        int soap_type() const { return SOAP_TYPE___ns1__BindingDevice; }
        /** Constructor with member initializations */
        __ns1__BindingDevice()
        {
          ns1__BindingDevice = (_ns1__BindingDevice *)0;
        }
        /** Friend allocator used by soap_new___ns1__BindingDevice(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__BindingDevice * SOAP_FMAC2 soap_instantiate___ns1__BindingDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2609 */
#ifndef SOAP_TYPE___ns1__GetDevice
#define SOAP_TYPE___ns1__GetDevice (150)
/* Wrapper: */
struct __ns1__GetDevice {
      public:
        /** Optional element 'ns1:GetDevice' of XSD type 'ns1:GetDevice' */
        _ns1__GetDevice *ns1__GetDevice;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetDevice */
        int soap_type() const { return SOAP_TYPE___ns1__GetDevice; }
        /** Constructor with member initializations */
        __ns1__GetDevice()
        {
          ns1__GetDevice = (_ns1__GetDevice *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetDevice(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetDevice * SOAP_FMAC2 soap_instantiate___ns1__GetDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2682 */
#ifndef SOAP_TYPE___ns1__SendSmartWarn
#define SOAP_TYPE___ns1__SendSmartWarn (154)
/* Wrapper: */
struct __ns1__SendSmartWarn {
      public:
        /** Optional element 'ns1:SendSmartWarn' of XSD type 'ns1:SendSmartWarn' */
        _ns1__SendSmartWarn *ns1__SendSmartWarn;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SendSmartWarn */
        int soap_type() const { return SOAP_TYPE___ns1__SendSmartWarn; }
        /** Constructor with member initializations */
        __ns1__SendSmartWarn()
        {
          ns1__SendSmartWarn = (_ns1__SendSmartWarn *)0;
        }
        /** Friend allocator used by soap_new___ns1__SendSmartWarn(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SendSmartWarn * SOAP_FMAC2 soap_instantiate___ns1__SendSmartWarn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2755 */
#ifndef SOAP_TYPE___ns1__PostListSmartWarn
#define SOAP_TYPE___ns1__PostListSmartWarn (158)
/* Wrapper: */
struct __ns1__PostListSmartWarn {
      public:
        /** Optional element 'ns1:PostListSmartWarn' of XSD type 'ns1:PostListSmartWarn' */
        _ns1__PostListSmartWarn *ns1__PostListSmartWarn;
      public:
        /** Return unique type id SOAP_TYPE___ns1__PostListSmartWarn */
        int soap_type() const { return SOAP_TYPE___ns1__PostListSmartWarn; }
        /** Constructor with member initializations */
        __ns1__PostListSmartWarn()
        {
          ns1__PostListSmartWarn = (_ns1__PostListSmartWarn *)0;
        }
        /** Friend allocator used by soap_new___ns1__PostListSmartWarn(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__PostListSmartWarn * SOAP_FMAC2 soap_instantiate___ns1__PostListSmartWarn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2828 */
#ifndef SOAP_TYPE___ns1__GetSmartWarn
#define SOAP_TYPE___ns1__GetSmartWarn (162)
/* Wrapper: */
struct __ns1__GetSmartWarn {
      public:
        /** Optional element 'ns1:GetSmartWarn' of XSD type 'ns1:GetSmartWarn' */
        _ns1__GetSmartWarn *ns1__GetSmartWarn;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSmartWarn */
        int soap_type() const { return SOAP_TYPE___ns1__GetSmartWarn; }
        /** Constructor with member initializations */
        __ns1__GetSmartWarn()
        {
          ns1__GetSmartWarn = (_ns1__GetSmartWarn *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetSmartWarn(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetSmartWarn * SOAP_FMAC2 soap_instantiate___ns1__GetSmartWarn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2901 */
#ifndef SOAP_TYPE___ns1__TotalSmartWarn
#define SOAP_TYPE___ns1__TotalSmartWarn (166)
/* Wrapper: */
struct __ns1__TotalSmartWarn {
      public:
        /** Optional element 'ns1:TotalSmartWarn' of XSD type 'ns1:TotalSmartWarn' */
        _ns1__TotalSmartWarn *ns1__TotalSmartWarn;
      public:
        /** Return unique type id SOAP_TYPE___ns1__TotalSmartWarn */
        int soap_type() const { return SOAP_TYPE___ns1__TotalSmartWarn; }
        /** Constructor with member initializations */
        __ns1__TotalSmartWarn()
        {
          ns1__TotalSmartWarn = (_ns1__TotalSmartWarn *)0;
        }
        /** Friend allocator used by soap_new___ns1__TotalSmartWarn(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__TotalSmartWarn * SOAP_FMAC2 soap_instantiate___ns1__TotalSmartWarn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:2974 */
#ifndef SOAP_TYPE___ns1__SendCarRunState
#define SOAP_TYPE___ns1__SendCarRunState (170)
/* Wrapper: */
struct __ns1__SendCarRunState {
      public:
        /** Optional element 'ns1:SendCarRunState' of XSD type 'ns1:SendCarRunState' */
        _ns1__SendCarRunState *ns1__SendCarRunState;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SendCarRunState */
        int soap_type() const { return SOAP_TYPE___ns1__SendCarRunState; }
        /** Constructor with member initializations */
        __ns1__SendCarRunState()
        {
          ns1__SendCarRunState = (_ns1__SendCarRunState *)0;
        }
        /** Friend allocator used by soap_new___ns1__SendCarRunState(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SendCarRunState * SOAP_FMAC2 soap_instantiate___ns1__SendCarRunState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:3047 */
#ifndef SOAP_TYPE___ns1__PostListCarRunState
#define SOAP_TYPE___ns1__PostListCarRunState (174)
/* Wrapper: */
struct __ns1__PostListCarRunState {
      public:
        /** Optional element 'ns1:PostListCarRunState' of XSD type 'ns1:PostListCarRunState' */
        _ns1__PostListCarRunState *ns1__PostListCarRunState;
      public:
        /** Return unique type id SOAP_TYPE___ns1__PostListCarRunState */
        int soap_type() const { return SOAP_TYPE___ns1__PostListCarRunState; }
        /** Constructor with member initializations */
        __ns1__PostListCarRunState()
        {
          ns1__PostListCarRunState = (_ns1__PostListCarRunState *)0;
        }
        /** Friend allocator used by soap_new___ns1__PostListCarRunState(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__PostListCarRunState * SOAP_FMAC2 soap_instantiate___ns1__PostListCarRunState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:3120 */
#ifndef SOAP_TYPE___ns1__GetCarRunState
#define SOAP_TYPE___ns1__GetCarRunState (178)
/* Wrapper: */
struct __ns1__GetCarRunState {
      public:
        /** Optional element 'ns1:GetCarRunState' of XSD type 'ns1:GetCarRunState' */
        _ns1__GetCarRunState *ns1__GetCarRunState;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCarRunState */
        int soap_type() const { return SOAP_TYPE___ns1__GetCarRunState; }
        /** Constructor with member initializations */
        __ns1__GetCarRunState()
        {
          ns1__GetCarRunState = (_ns1__GetCarRunState *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetCarRunState(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetCarRunState * SOAP_FMAC2 soap_instantiate___ns1__GetCarRunState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* adas.h:3665 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (179)
/* SOAP_ENV__Header: */
struct SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* adas.h:3665 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (180)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* adas.h:3665 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (182)
/* SOAP_ENV__Detail: */
struct SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* adas.h:3665 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (185)
/* SOAP_ENV__Reason: */
struct SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* adas.h:3665 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (186)
/* SOAP_ENV__Fault: */
struct SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* adas.h:123 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* adas.h:123 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* adas.h:159 */
#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (13)
typedef char xsd__byte;
#endif

/* adas.h:165 */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (18)
typedef unsigned char xsd__unsignedByte;
#endif

/* adas.h:168 */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (20)
typedef std::wstring xsd__ID;
#endif

/* adas.h:178 */
#ifndef SOAP_TYPE_xsd__IDREF
#define SOAP_TYPE_xsd__IDREF (22)
typedef std::wstring xsd__IDREF;
#endif

/* adas.h:195 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (25)
typedef std::wstring xsd__anyURI;
#endif

/* adas.h:233 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (33)
typedef std::wstring xsd__decimal;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* xsd__byte has binding name 'xsd__byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (13)
#endif

/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* short has binding name 'short' for type 'xsd:short' */
#ifndef SOAP_TYPE_short
#define SOAP_TYPE_short (44)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (42)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (17)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (39)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (36)
#endif

/* xsd__unsignedByte has binding name 'xsd__unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (18)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (11)
#endif

/* unsigned short has binding name 'unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_unsignedShort
#define SOAP_TYPE_unsignedShort (51)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (10)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (49)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (32)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (29)
#endif

/* arr__ArrayOfstring has binding name 'arr__ArrayOfstring' for type 'arr:ArrayOfstring' */
#ifndef SOAP_TYPE_arr__ArrayOfstring
#define SOAP_TYPE_arr__ArrayOfstring (92)
#endif

/* ns2__PrimeAccount has binding name 'ns2__PrimeAccount' for type 'ns2:PrimeAccount' */
#ifndef SOAP_TYPE_ns2__PrimeAccount
#define SOAP_TYPE_ns2__PrimeAccount (91)
#endif

/* ns2__ArrayOfPrimeAccount has binding name 'ns2__ArrayOfPrimeAccount' for type 'ns2:ArrayOfPrimeAccount' */
#ifndef SOAP_TYPE_ns2__ArrayOfPrimeAccount
#define SOAP_TYPE_ns2__ArrayOfPrimeAccount (90)
#endif

/* _ns1__GetCarRunStateResponse has binding name '_ns1__GetCarRunStateResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCarRunStateResponse
#define SOAP_TYPE__ns1__GetCarRunStateResponse (89)
#endif

/* _ns1__GetCarRunState has binding name '_ns1__GetCarRunState' for type '' */
#ifndef SOAP_TYPE__ns1__GetCarRunState
#define SOAP_TYPE__ns1__GetCarRunState (88)
#endif

/* _ns1__PostListCarRunStateResponse has binding name '_ns1__PostListCarRunStateResponse' for type '' */
#ifndef SOAP_TYPE__ns1__PostListCarRunStateResponse
#define SOAP_TYPE__ns1__PostListCarRunStateResponse (87)
#endif

/* _ns1__PostListCarRunState has binding name '_ns1__PostListCarRunState' for type '' */
#ifndef SOAP_TYPE__ns1__PostListCarRunState
#define SOAP_TYPE__ns1__PostListCarRunState (86)
#endif

/* _ns1__SendCarRunStateResponse has binding name '_ns1__SendCarRunStateResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SendCarRunStateResponse
#define SOAP_TYPE__ns1__SendCarRunStateResponse (85)
#endif

/* _ns1__SendCarRunState has binding name '_ns1__SendCarRunState' for type '' */
#ifndef SOAP_TYPE__ns1__SendCarRunState
#define SOAP_TYPE__ns1__SendCarRunState (84)
#endif

/* _ns1__TotalSmartWarnResponse has binding name '_ns1__TotalSmartWarnResponse' for type '' */
#ifndef SOAP_TYPE__ns1__TotalSmartWarnResponse
#define SOAP_TYPE__ns1__TotalSmartWarnResponse (83)
#endif

/* _ns1__TotalSmartWarn has binding name '_ns1__TotalSmartWarn' for type '' */
#ifndef SOAP_TYPE__ns1__TotalSmartWarn
#define SOAP_TYPE__ns1__TotalSmartWarn (82)
#endif

/* _ns1__GetSmartWarnResponse has binding name '_ns1__GetSmartWarnResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetSmartWarnResponse
#define SOAP_TYPE__ns1__GetSmartWarnResponse (81)
#endif

/* _ns1__GetSmartWarn has binding name '_ns1__GetSmartWarn' for type '' */
#ifndef SOAP_TYPE__ns1__GetSmartWarn
#define SOAP_TYPE__ns1__GetSmartWarn (80)
#endif

/* _ns1__PostListSmartWarnResponse has binding name '_ns1__PostListSmartWarnResponse' for type '' */
#ifndef SOAP_TYPE__ns1__PostListSmartWarnResponse
#define SOAP_TYPE__ns1__PostListSmartWarnResponse (79)
#endif

/* _ns1__PostListSmartWarn has binding name '_ns1__PostListSmartWarn' for type '' */
#ifndef SOAP_TYPE__ns1__PostListSmartWarn
#define SOAP_TYPE__ns1__PostListSmartWarn (78)
#endif

/* _ns1__SendSmartWarnResponse has binding name '_ns1__SendSmartWarnResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SendSmartWarnResponse
#define SOAP_TYPE__ns1__SendSmartWarnResponse (77)
#endif

/* _ns1__SendSmartWarn has binding name '_ns1__SendSmartWarn' for type '' */
#ifndef SOAP_TYPE__ns1__SendSmartWarn
#define SOAP_TYPE__ns1__SendSmartWarn (76)
#endif

/* _ns1__GetDeviceResponse has binding name '_ns1__GetDeviceResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetDeviceResponse
#define SOAP_TYPE__ns1__GetDeviceResponse (75)
#endif

/* _ns1__GetDevice has binding name '_ns1__GetDevice' for type '' */
#ifndef SOAP_TYPE__ns1__GetDevice
#define SOAP_TYPE__ns1__GetDevice (74)
#endif

/* _ns1__BindingDeviceResponse has binding name '_ns1__BindingDeviceResponse' for type '' */
#ifndef SOAP_TYPE__ns1__BindingDeviceResponse
#define SOAP_TYPE__ns1__BindingDeviceResponse (73)
#endif

/* _ns1__BindingDevice has binding name '_ns1__BindingDevice' for type '' */
#ifndef SOAP_TYPE__ns1__BindingDevice
#define SOAP_TYPE__ns1__BindingDevice (72)
#endif

/* _ns1__SaleDeviceResponse has binding name '_ns1__SaleDeviceResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SaleDeviceResponse
#define SOAP_TYPE__ns1__SaleDeviceResponse (71)
#endif

/* _ns1__SaleDevice has binding name '_ns1__SaleDevice' for type '' */
#ifndef SOAP_TYPE__ns1__SaleDevice
#define SOAP_TYPE__ns1__SaleDevice (70)
#endif

/* _ns1__MadeDeviceResponse has binding name '_ns1__MadeDeviceResponse' for type '' */
#ifndef SOAP_TYPE__ns1__MadeDeviceResponse
#define SOAP_TYPE__ns1__MadeDeviceResponse (69)
#endif

/* _ns1__MadeDevice has binding name '_ns1__MadeDevice' for type '' */
#ifndef SOAP_TYPE__ns1__MadeDevice
#define SOAP_TYPE__ns1__MadeDevice (68)
#endif

/* _ns1__CreateDeviceResponse has binding name '_ns1__CreateDeviceResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CreateDeviceResponse
#define SOAP_TYPE__ns1__CreateDeviceResponse (67)
#endif

/* _ns1__CreateDevice has binding name '_ns1__CreateDevice' for type '' */
#ifndef SOAP_TYPE__ns1__CreateDevice
#define SOAP_TYPE__ns1__CreateDevice (66)
#endif

/* _ns1__EditAccountResponse has binding name '_ns1__EditAccountResponse' for type '' */
#ifndef SOAP_TYPE__ns1__EditAccountResponse
#define SOAP_TYPE__ns1__EditAccountResponse (65)
#endif

/* _ns1__EditAccount has binding name '_ns1__EditAccount' for type '' */
#ifndef SOAP_TYPE__ns1__EditAccount
#define SOAP_TYPE__ns1__EditAccount (64)
#endif

/* _ns1__SetAccountResponse has binding name '_ns1__SetAccountResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetAccountResponse
#define SOAP_TYPE__ns1__SetAccountResponse (63)
#endif

/* _ns1__SetAccount has binding name '_ns1__SetAccount' for type '' */
#ifndef SOAP_TYPE__ns1__SetAccount
#define SOAP_TYPE__ns1__SetAccount (62)
#endif

/* _ns1__SelectAccountResponse has binding name '_ns1__SelectAccountResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SelectAccountResponse
#define SOAP_TYPE__ns1__SelectAccountResponse (61)
#endif

/* _ns1__SelectAccount has binding name '_ns1__SelectAccount' for type '' */
#ifndef SOAP_TYPE__ns1__SelectAccount
#define SOAP_TYPE__ns1__SelectAccount (60)
#endif

/* _ns1__GetAccountResponse has binding name '_ns1__GetAccountResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetAccountResponse
#define SOAP_TYPE__ns1__GetAccountResponse (59)
#endif

/* _ns1__GetAccount has binding name '_ns1__GetAccount' for type '' */
#ifndef SOAP_TYPE__ns1__GetAccount
#define SOAP_TYPE__ns1__GetAccount (58)
#endif

/* _ns1__LoginCloudResponse has binding name '_ns1__LoginCloudResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LoginCloudResponse
#define SOAP_TYPE__ns1__LoginCloudResponse (57)
#endif

/* _ns1__LoginCloud has binding name '_ns1__LoginCloud' for type '' */
#ifndef SOAP_TYPE__ns1__LoginCloud
#define SOAP_TYPE__ns1__LoginCloud (56)
#endif

/* _ns1__UpdatePassWordResponse has binding name '_ns1__UpdatePassWordResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UpdatePassWordResponse
#define SOAP_TYPE__ns1__UpdatePassWordResponse (55)
#endif

/* _ns1__UpdatePassWord has binding name '_ns1__UpdatePassWord' for type '' */
#ifndef SOAP_TYPE__ns1__UpdatePassWord
#define SOAP_TYPE__ns1__UpdatePassWord (54)
#endif

/* _ns1__RegisterAccountResponse has binding name '_ns1__RegisterAccountResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RegisterAccountResponse
#define SOAP_TYPE__ns1__RegisterAccountResponse (53)
#endif

/* _ns1__RegisterAccount has binding name '_ns1__RegisterAccount' for type '' */
#ifndef SOAP_TYPE__ns1__RegisterAccount
#define SOAP_TYPE__ns1__RegisterAccount (52)
#endif

/* xsd__unsignedShort has binding name 'xsd__unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_xsd__unsignedShort
#define SOAP_TYPE_xsd__unsignedShort (50)
#endif

/* xsd__unsignedLong has binding name 'xsd__unsignedLong' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (48)
#endif

/* xsd__unsignedInt has binding name 'xsd__unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (47)
#endif

/* xsd__unsignedByte_ has binding name 'xsd__unsignedByte_' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_xsd__unsignedByte_
#define SOAP_TYPE_xsd__unsignedByte_ (46)
#endif

/* xsd__string has binding name 'xsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (45)
#endif

/* xsd__short has binding name 'xsd__short' for type 'xsd:short' */
#ifndef SOAP_TYPE_xsd__short
#define SOAP_TYPE_xsd__short (43)
#endif

/* xsd__long has binding name 'xsd__long' for type 'xsd:long' */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (41)
#endif

/* xsd__int has binding name 'xsd__int' for type 'xsd:int' */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (40)
#endif

/* xsd__float has binding name 'xsd__float' for type 'xsd:float' */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (38)
#endif

/* xsd__duration_ has binding name 'xsd__duration_' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (37)
#endif

/* xsd__double has binding name 'xsd__double' for type 'xsd:double' */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (35)
#endif

/* xsd__decimal_ has binding name 'xsd__decimal_' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal_
#define SOAP_TYPE_xsd__decimal_ (34)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (33)
#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (31)
#endif

/* xsd__byte_ has binding name 'xsd__byte_' for type 'xsd:byte' */
#ifndef SOAP_TYPE_xsd__byte_
#define SOAP_TYPE_xsd__byte_ (30)
#endif

/* xsd__boolean has binding name 'xsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (28)
#endif

/* xsd__base64Binary_ has binding name 'xsd__base64Binary_' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (27)
#endif

/* xsd__anyURI_ has binding name 'xsd__anyURI_' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (26)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (25)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (24)
#endif

/* xsd__IDREF_ has binding name 'xsd__IDREF_' for type 'xsd:IDREF' */
#ifndef SOAP_TYPE_xsd__IDREF_
#define SOAP_TYPE_xsd__IDREF_ (23)
#endif

/* xsd__IDREF has binding name 'xsd__IDREF' for type 'xsd:IDREF' */
#ifndef SOAP_TYPE_xsd__IDREF
#define SOAP_TYPE_xsd__IDREF (22)
#endif

/* xsd__ID_ has binding name 'xsd__ID_' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID_
#define SOAP_TYPE_xsd__ID_ (21)
#endif

/* xsd__ID has binding name 'xsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (20)
#endif

/* std::wstring has binding name 'std__wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__wstring
#define SOAP_TYPE_std__wstring (19)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (9)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (7)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (186)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (185)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (182)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (180)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (179)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (188)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (187)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (181)
#endif

/* _ns1__GetCarRunState * has binding name 'PointerTo_ns1__GetCarRunState' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCarRunState
#define SOAP_TYPE_PointerTo_ns1__GetCarRunState (175)
#endif

/* _ns1__PostListCarRunState * has binding name 'PointerTo_ns1__PostListCarRunState' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__PostListCarRunState
#define SOAP_TYPE_PointerTo_ns1__PostListCarRunState (171)
#endif

/* _ns1__SendCarRunState * has binding name 'PointerTo_ns1__SendCarRunState' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SendCarRunState
#define SOAP_TYPE_PointerTo_ns1__SendCarRunState (167)
#endif

/* _ns1__TotalSmartWarn * has binding name 'PointerTo_ns1__TotalSmartWarn' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__TotalSmartWarn
#define SOAP_TYPE_PointerTo_ns1__TotalSmartWarn (163)
#endif

/* _ns1__GetSmartWarn * has binding name 'PointerTo_ns1__GetSmartWarn' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSmartWarn
#define SOAP_TYPE_PointerTo_ns1__GetSmartWarn (159)
#endif

/* _ns1__PostListSmartWarn * has binding name 'PointerTo_ns1__PostListSmartWarn' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__PostListSmartWarn
#define SOAP_TYPE_PointerTo_ns1__PostListSmartWarn (155)
#endif

/* _ns1__SendSmartWarn * has binding name 'PointerTo_ns1__SendSmartWarn' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SendSmartWarn
#define SOAP_TYPE_PointerTo_ns1__SendSmartWarn (151)
#endif

/* _ns1__GetDevice * has binding name 'PointerTo_ns1__GetDevice' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetDevice
#define SOAP_TYPE_PointerTo_ns1__GetDevice (147)
#endif

/* _ns1__BindingDevice * has binding name 'PointerTo_ns1__BindingDevice' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BindingDevice
#define SOAP_TYPE_PointerTo_ns1__BindingDevice (143)
#endif

/* _ns1__SaleDevice * has binding name 'PointerTo_ns1__SaleDevice' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SaleDevice
#define SOAP_TYPE_PointerTo_ns1__SaleDevice (139)
#endif

/* _ns1__MadeDevice * has binding name 'PointerTo_ns1__MadeDevice' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__MadeDevice
#define SOAP_TYPE_PointerTo_ns1__MadeDevice (135)
#endif

/* _ns1__CreateDevice * has binding name 'PointerTo_ns1__CreateDevice' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateDevice
#define SOAP_TYPE_PointerTo_ns1__CreateDevice (131)
#endif

/* _ns1__EditAccount * has binding name 'PointerTo_ns1__EditAccount' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__EditAccount
#define SOAP_TYPE_PointerTo_ns1__EditAccount (127)
#endif

/* _ns1__SetAccount * has binding name 'PointerTo_ns1__SetAccount' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetAccount
#define SOAP_TYPE_PointerTo_ns1__SetAccount (123)
#endif

/* _ns1__SelectAccount * has binding name 'PointerTo_ns1__SelectAccount' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SelectAccount
#define SOAP_TYPE_PointerTo_ns1__SelectAccount (119)
#endif

/* _ns1__GetAccount * has binding name 'PointerTo_ns1__GetAccount' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetAccount
#define SOAP_TYPE_PointerTo_ns1__GetAccount (115)
#endif

/* _ns1__LoginCloud * has binding name 'PointerTo_ns1__LoginCloud' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LoginCloud
#define SOAP_TYPE_PointerTo_ns1__LoginCloud (111)
#endif

/* _ns1__UpdatePassWord * has binding name 'PointerTo_ns1__UpdatePassWord' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UpdatePassWord
#define SOAP_TYPE_PointerTo_ns1__UpdatePassWord (107)
#endif

/* _ns1__RegisterAccount * has binding name 'PointerTo_ns1__RegisterAccount' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RegisterAccount
#define SOAP_TYPE_PointerTo_ns1__RegisterAccount (103)
#endif

/* std::wstring * has binding name 'PointerTostd__wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__wstring
#define SOAP_TYPE_PointerTostd__wstring (102)
#endif

/* xsd__base64Binary * has binding name 'PointerToxsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_PointerToxsd__base64Binary
#define SOAP_TYPE_PointerToxsd__base64Binary (101)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (100)
#endif

/* ns2__PrimeAccount ** has binding name 'PointerToPointerTons2__PrimeAccount' for type 'ns2:PrimeAccount' */
#ifndef SOAP_TYPE_PointerToPointerTons2__PrimeAccount
#define SOAP_TYPE_PointerToPointerTons2__PrimeAccount (99)
#endif

/* arr__ArrayOfstring * has binding name 'PointerToarr__ArrayOfstring' for type 'arr:ArrayOfstring' */
#ifndef SOAP_TYPE_PointerToarr__ArrayOfstring
#define SOAP_TYPE_PointerToarr__ArrayOfstring (98)
#endif

/* ns2__PrimeAccount * has binding name 'PointerTons2__PrimeAccount' for type 'ns2:PrimeAccount' */
#ifndef SOAP_TYPE_PointerTons2__PrimeAccount
#define SOAP_TYPE_PointerTons2__PrimeAccount (97)
#endif

/* ns2__ArrayOfPrimeAccount * has binding name 'PointerTons2__ArrayOfPrimeAccount' for type 'ns2:ArrayOfPrimeAccount' */
#ifndef SOAP_TYPE_PointerTons2__ArrayOfPrimeAccount
#define SOAP_TYPE_PointerTons2__ArrayOfPrimeAccount (96)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (95)
#endif

/* wchar_t * has binding name 'wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_wstring
#define SOAP_TYPE_wstring (94)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (12)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
